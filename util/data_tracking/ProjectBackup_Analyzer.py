# Tracks a database of XLIFF backups generated by Connor TBX and produces meaningful churn data through change_tracker.

from datetime import datetime
from pathlib import Path
import os
from util.xliff.xliff import File as Xliff
from util.data_tracking.change_tracker import FileChanges
from datetime import datetime
import pandas


class ProjectBackupDB:
    def __init__(self):
        self.filelist = []  # list[FileHistory]


    @classmethod
    def from_ConnorTBX(cls, backuppath: Path, currentpath: Path):
        created = ProjectBackupDB()
        # first, get list of all unique filenames, deleted and not deleted
        unique_filepaths = []
        #   from currentpath:
        for filepath in currentpath.rglob("*.xliff"):
            if filepath.relative_to(currentpath) not in unique_filepaths:
                unique_filepaths.append(filepath.relative_to(currentpath))
        #   from backups:
        # go folder by folder, then within the folder, do rglob
        backupdirs = backuppath.glob("*/")
        for backupfolder in backupdirs:
            # generate
            for filepath in backupfolder.rglob("*.xliff"):
                if filepath.relative_to(backupfolder) not in unique_filepaths:
                    unique_filepaths.append(filepath.relative_to(backupfolder))
        # now that we have a list, create a FileHistory object for every file.
        filelist = []
        for filepath in unique_filepaths:
            filelist.append(FileHistory.from_scratch(filepath, backuppath, currentpath))
        created.filelist = filelist
        return created

    def create_churn_excel(self, savepath: Path):
        # first, create master dict for pandas import
        DB_dict = {file.relpath:file.analyze_file_churn() for file in self.filelist}
        my_dataframe = pandas.DataFrame.from_dict(DB_dict)
        my_dataframe.to_excel(savepath)

class FileHistory:
    def __init__(self):
        self.relpath = None
        self.snapshots = []
        self.snapshots_by_date = {}

    def update(self):
        # sort snapshots list by date
        self.snapshots.sort(key=lambda x:x.date, reverse=True) # Newest to Oldest
        # create snapshots by date
        self.snapshots_by_date = {file.date: file for file in self.snapshots}


    @classmethod
    def from_scratch(cls, filepath, backuppath, currentpath):
        created = FileHistory()
        created.relpath = filepath
        snapshots = []
        # Crawl the current path, then backuppath to find instances of the file
        if (currentpath / filepath).exists():
            snapshots.append(FileSnapshot.from_scratch((currentpath / filepath)))
        backupdirs = backuppath.glob("*/")
        for backupfolder in backupdirs:
            if (backupfolder / filepath).exists():
                snapshots.append(FileSnapshot.from_scratch((backupfolder / filepath)))
        created.snapshots = snapshots
        created.update()
        return created

    def analyze_file_churn(self):
        analysis_for_pandas = {"Filepath": self.relpath}
        # analyzes the differences between each file
        for i, element in enumerate(self.snapshots):
            newer_file = Xliff.from_file(element.path, element.path)
            if i >= len(self.snapshots) - 1:
                break
            older_file = Xliff.from_file(self.snapshots[i + 1].path, self.snapshots[i + 1].path)
            changelog = FileChanges.create_from_xliffs(older_file, newer_file)
            # get delta number from changelog
            deltanumber = sum([changelog.additions, changelog.deletions, changelog.MajorChanges[0], changelog.MinorChanges[0], sum(changelog.CommentChanges)])
            analysis_for_pandas[element.date] = deltanumber
        # then produces a dict of {filepath: path, date: churn, date: churn...}
        return analysis_for_pandas

class FileSnapshot:
    def __init__(self):
        self.path = None
        self.date = None

    @classmethod
    def from_scratch(cls, filepath):
        created = FileSnapshot()
        created.path = filepath
        created.date = datetime.fromtimestamp(os.path.getmtime(filepath)).strftime('%Y-%m-%d')
        return created

